'''
    AUTHOR: Louis-Hendrik Barboutie
    CONTACT: louis.barboutie@gmail.com, loubar-3@student.ltu.se
    
    SUMMARY: The script runs a matplotlib animation to plot out the data received by the RAVEN test stand. The incoming data comes from a csv file generated by the
        serial_reader.py script, which itself receives the data from the SerialComms.cpp script. The interface is manually designed and an animation function
        handles the updating of the animated artists.

    SCRIPT STRUCTURE:

    DIRECTORY STRUCTURE:
        |
        +-- interface.py
        +-- indicatorClass.py
        +-- dataDisplayClass.py
        +-- data.csv

    CHANGELOG: 
        - 06/12/23: Improve handling of graph labelling, make displays work, add rolling average
        - 15/11/23: Added escape key press handling, header comment
        - 08/11/23: Successful implementation of animation with dummy data

    TODO:
        - Add function to automatically save file upon closing
        - read data properly from csv file
        - add message box for software mode, substate and arduino time
        - add function to compute the rolling average
        - add display of latest value on graphs
        - improve artist list in 
'''

# ================= #
# === LIBRARIES === #
# ================= #

# external
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.animation as ani
import numpy as np
import csv

# internal (functions)
# from update import update 
import indicatorClass as ic
import displayClass as dc
from dataDefinitions import data
from rollingAverage import rollingAverage




# ================= #
# === VARIABLES === #
# ================= #

nData = len(data)
nDataPoints = 25

# ======================= #
# === INTERFACE SETUP === #
# ======================= #

# remove toolbar
plt.rcParams['toolbar'] = 'None'

# select backend
mpl.use("qtagg")

# create figure interface and separate panels for graphs, displays and indicators
interface = plt.figure(facecolor='silver') 
dataPanel, infoPanel = interface.subfigures(1, 2, width_ratios=[3,1]) 
indicatorPanel, streamPanel = infoPanel.subfigures(2, 1, height_ratios=[3,2])
displayPanel, lightsPanel = indicatorPanel.subfigures(1,2)

# adjust background colors of the subfigures
dataPanel.set_facecolor('silver')
lightsPanel.set_facecolor('slategrey')
displayPanel.set_facecolor('green')
streamPanel.set_facecolor('red')

# ------------------ #
# --- DATA PANEL --- #
# ------------------ #

# create subplot layout for the graphs
graphs = dataPanel.subplots(4, 2)

# adjust spacing so that graphs don't overlap and fill out whole panel
dataPanel.subplots_adjust(left=0.05, right=0.99, bottom=0.03, top=0.97, wspace=0.15, hspace=0.4)

# fontsize definitions for axis labeling
labelFontSize = 9
tickFontSize = 7

# add titles and axis labels to the graphs
for i in range(4):
    for j in range(2):
        xLabel = '%s [%s]' % (data[i+j*4]['xLabel'], data[i+j*4]['xUnit'])
        yLabel = '%s [%s]' % (data[i+j*4]['yLabel'], data[i+j*4]['yUnit'])
        graphs[i,j].set_xlabel(xLabel, fontsize=labelFontSize)
        graphs[i,j].set_ylabel(yLabel, fontsize=labelFontSize)
        graphs[i,j].set_xlim(0, nDataPoints-1)
        graphs[i,j].set_ylim(data[i+j*4]['yLowerBound'], data[i+j*4]['yUpperBound'])
        graphs[i,j].set_title(data[i+j*4]['title'])
        graphs[i,j].tick_params(
            axis='y',
            labelsize=tickFontSize)
        graphs[i,j].tick_params(
            axis='x',          # changes apply to the x-axis
            which='both',      # both major and minor ticks are affected
            bottom=False,      # ticks along the bottom edge are off
            top=False,         # ticks along the top edge are off
            labelbottom=False) # labels along the bottom edge are off
        graphs[i,j].grid(linestyle='--')

dataLines = []
avgLines = []
for i in range(4):
    for j in range(2):
        dataLines.append(graphs[i][j].plot([], [], color='black')[0])
        avgLines.append(graphs[i][j].axhline(color='red', linestyle=':'))

    

# ------------------ #
# --- INFO PANEL --- #
# ------------------ #

# create indicator and state list for easy access
indicatorObjects = [ic.indicatorLight('Heating\nBlanket'),
              ic.indicatorLight('Main\nValve'),
              ic.indicatorLight('Ignition\nRelay')]
nIndicators = len(indicatorObjects)
indicatorStates = [0, 0, 0]
indicatorLabels = []

# create subplots for the info panel
indicators = lightsPanel.subplots(nIndicators, 1)

# adjust spacing so that info boxes don't overlap and fill out whole panel
lightsPanel.subplots_adjust(left=0.04, right=0.98, bottom=0.05, top=0.97, wspace=0.15, hspace=0.1)

# remove graph background and set title and square aspect ratio of the subplots
# add indicator artists
for i in range(nIndicators):
    indicators[i].set_aspect('equal', 'box')
    indicators[i].axis('off')
    indicatorLabels.append(indicators[i].text(0.5, 0.48, indicatorObjects[i].title, fontsize=indicatorObjects[i].fontSize, ha='center', va='center'))
    for j in range(len(indicatorObjects[i].objects)):
            indicators[i].add_artist(indicatorObjects[i].objects[j])

### DEBUG ### ----------------------------------------------------------------------------------------------------------------------------------
indicatorObjects[0].setState(1)
    

# --------------------- #
# --- DATA DISPLAYS --- #
# --------------------- #

# create display objects and value list
displayObjects = [dc.displayBox('Bottle Pressure'),
            dc.displayBox('Bottle Temperature'),
            dc.displayBox('Load Cell Force')]
nDisplays = len(displayObjects) 
displayValues = [''] * nDisplays
displayObjects[0].setValue('text')
# create subplots for the info panel
displays = displayPanel.subplots(nDisplays, 1)

# adjust subplot geometry
#displayObjects.subplots_adjust(left=0.04, right=0.98, bottom=0.05, top=0.97, wspace=0.15, hspace=0.1)

# remove graph background and set aspect ratio of the displays
for i in range(nDisplays):
    displays[i].set_aspect(aspect=0.4)
    displays[i].axis('off')

# add display artists and format display axes
for i in range(nDisplays):
    for j in range(len(displayObjects[i].objects)):
        displays[i].add_artist(displayObjects[i].objects[j])
    displays[i].set_title(displayObjects[i].title, fontsize=displayObjects[i].fontSize)
    displayValues[i] = displays[i].text(0.5, 0.48, displayObjects[i].value, fontsize=displayObjects[i].fontSize, ha='center', va='center')

# =========================== #
# === INTERFACE ANIMATION === #
# =========================== #

# --------------------------------- #
# --- ADD ARTISTS TO THE GRAPHS --- #
# --------------------------------- #

artists = dataLines + avgLines # nData*2 elements
for i in range(nIndicators):
    artists += indicatorObjects[i].objects # nIndicator*4 elements
    artists.append(indicatorLabels[i])
for i in range(nDisplays):
    artists += displayObjects[i].objects # nDisplays*2 elements
    artists.append(displayValues[i])

# initialize lists for holding the data
x_data = [[0] * nDataPoints] * nData
y_data = [[0] * nDataPoints] * nData
averages = [0] * nData

for i in range(nData):
    for j in range(nDataPoints):
        x_data[i][j] = j

# initialize line data
for i in range(nData):
    artists[i].set_data(x_data[i], y_data[i])
    artists[nData + i].set_ydata([nDataPoints])

# TO BE REMOVED =====================
indicatorStates = [1,0,0]
### =================================

lastFilePosition = 0

def update(frame):
    global lastFilePosition
    global indicatorStates

    # ------------------------------- #
    # --- READ DATA FROM CSV FILE --- #
    # ------------------------------- #

    with open('dummyData.csv', 'r', newline='') as dataFile:
        dataFile.seek(lastFilePosition)
        csvReader = csv.reader(dataFile)
        for row in csvReader:
            for i in range(8):
                y_data[i].pop(0)
                y_data[i].append(float(row[i+1]))
        lastFilePosition = dataFile.tell()

    # ---------------------------- #
    # --- UPDATE DATA IN PLOTS --- #
    # ---------------------------- #

    # update the data points and average calculations
    for i in range(nData):
        averages[i] = rollingAverage(y_data[i])
        artists[i].set_ydata(y_data[i])
        artists[nData + i].set_ydata([averages[i]])

    # ----------------------------------------- #
    # --- DUMMY UPDATE THE INDICATOR LIGHTS --- #
    # ----------------------------------------- #

    # dummy cycle indicator list around
    if frame % 10 == 0:
        item = indicatorStates[0]
        indicatorStates.pop(0)
        indicatorStates.append(item)

    # update the indicator state
    for i in range(nIndicators):
        indicatorObjects[i].setState(indicatorStates[i])
    
    # ----------------------------- #
    # --- UPDATE DISPLAY VALUES --- #
    # ----------------------------- #
    
    for i in range(nDisplays):
         artists[2*nData + 5*nIndicators+ 2*(i+1) + i].set_text('%.2f' %(averages[i]))

    return  artists

# toggle fullscreen
plt.get_current_fig_manager().full_screen_toggle()

# animation settings
isUsingBlit = True
isCachingFrameData = False
updateRate = 10 # milli seconds

# function to add escape key press to exit figure
def escape(esc):
    if esc.key == 'escape':
        plt.close()

# link the key press event to the interface
interface.canvas.mpl_connect('key_press_event', escape)

# animate the interface
interfaceAnimation = ani.FuncAnimation(interface, update, interval=updateRate, blit=isUsingBlit, cache_frame_data=isCachingFrameData)
plt.show()
